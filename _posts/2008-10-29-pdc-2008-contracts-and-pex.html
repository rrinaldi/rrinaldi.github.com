<ul> <li>Contract based development</li> <ul> <li>Add contracts to code that ensure adherence to spec and implementation</li> <ul> <li>Contract.Requires( 0 &lt; x);</li> <li>Contract.Ensures(Contract.Result&lt;string&gt;() != null)</li> <li>System.Diagnostics.Contracts</li> <li>.NET 4.0</li></ul> <li>Contracts document design decisions</li> <li>Contracts are executable</li> <ul> <li>Checked documentation</li></ul> <li>Contracts help static verification</li> <li>Assertions help, but not perfect</li> <ul> <li>Not a contract between 2 parties</li></ul> <li>Demo of contracts</li> <ul> <li>Creating a Rational number</li> <li>You can get a preview of code contracts now for 2008</li> <li>By default it looks at IL and can generate warnings of possible runtime errors even without any contracts</li> <li>Adding contracts make the contracts part of the method signature</li> <li>Contracts look at the type as a whole, not just the standard constructor</li> <ul> <li>Use ObjectInvariant method</li> <ul> <li>This binds the object to a state that has to be true at the end of each method and each constructor</li></ul></ul> <li>Using Pex with Contracts</li> <ul> <li>Pex finds all the values that would violate the contract</li></ul></ul> <li>What can I do with Contracts?</li> <ul> <li>Static Checking</li> <li>Runtime Checking</li> <li>Test Generation (Pex)</li> <li>Documentation</li></ul> <li>What contracts are there?</li> <ul> <li>Requires</li> <li>Ensures</li> <ul> <li>what is true at method exit</li></ul> <li>Invariants</li> <ul> <li>what is true at ANY method exit</li></ul></ul> <li>What can be put in a contract?</li> <ul> <li>Any boolean expression (including method calls)</li> <ul> <li>Contract.Requires( value != null);</li></ul> <li>Contract.Result</li> <ul> <li>Contract.Ensures(Contract.Result&lt;int&gt;() == Contract.OldValue(Count));</li></ul> <li>(SOMETHING ELSE that i missed. Grr)</li></ul> <li>Contracts are declarative</li> <ul> <li>They are executed at the proper point in the chain no matter where they are called</li></ul> <li>Demo of an ArrayList full of contracts (Runtime validations)</li> <ul> <li>There is a subtype that overrides Add and returns -1 which violates the Add contract</li> <li>Contracts get populated into subtypes</li> <ul> <li>The tool takes care of contract injections</li></ul></ul> <li>Probably don't want to put contracts out there in Release builds</li> <ul> <li>If you still want them in Release there are other methods to use to put them into release builds</li> <li>If you don't want them in Release the standard methods will exclude the contracts (faster)</li></ul> <li>Static Contract Checking</li> <ul> <li>Analyzes all execution paths</li> <li>Guides development</li> <li>Not only explicit contracts</li> <ul> <li>De-referencing null</li> <li>indexing arrays</li> <li>Arithmetic exceptions</li></ul></ul> <li>What gets shipped?</li> <ul> <li>Release assemblies + Contract Reference assemblies</li> <ul> <li>Contract Reference Assemblies are all contracts, no code</li></ul></ul> <li>Interface Contracts</li> <ul> <li>ContractClass attribute </li> <li>ContractClassFor attribute</li></ul> <li>Summary</li> <ul> <li>Contract library class for all .NET languages</li> <li>Contracts are being used in the BCL today</li> <li>Same contracts used for</li> <ul> <li>Runtime checking</li> <li>Static checking</li> <li>Documentation generation</li></ul></ul></ul> <li>PEX</li> <ul> <li>Testing before Pex</li> <ul> <li>Testing is tedious</li> <li>too easy to miss cases</li> <li>old tests get stale</li> <li>too much legacy code - what does it do?</li></ul> <li>Tests for free: Demo</li> <ul> <li>Using Pex Explorations you can see all the branches and all the values that execute those branches</li> <li>Any Pex exploration can be saved as a unit test</li> <li>Just right click in code -&gt; explore -&gt; get test cases for free</li></ul> <li>Demo: Using Pex to explore a class in NHibernate (Typename Parser)</li> <ul> <li>Generates 31 different test cases</li> <li>All MSTest cases </li> <li>Pex gives you 100% Code Coverage</li> <li>Once you start to understand code, you should start adding contracts and running more explorations to validate those contracts</li></ul> <li>Pex gives you high code coverage and generates automagically pretty good test suites</li> <li>Pex finds contract violations</li> <li>Integrates with VS Team Test</li> <li>can be used as Build Verification tests </li> <ul> <li>Very targeted small tests</li></ul> <li>PexMethods</li> <ul> <li>Parameterized Unit Test</li> <ul> <li>A unit test method that takes parameters</li></ul> <li>Pex generates traditional Unit Tests in C# which fix particular values</li></ul> <li>How to test this code? Demo</li> <ul> <li>ResourceReader</li> <li>It takes a stream</li> <li>It gets down to reading bytes from a stream that can be ugly (includes magic numbers)</li> <li>With parameterized tests you need to do some setup and create a viable scenario for testing</li> <li>Everytime Pex finds a branch it creates a test case.</li> <li>You can tell Pex what exceptions are acceptable and it will only flag un-expected exceptions as errors</li></ul> <li>Pex understands code</li> <ul> <li>Pex does not guess</li> <li>Pex does not enumerate all possible values</li> <li>Pex does not make you write test input generators</li> <li>Pex partitions inputs into equivalance classes</li> <li>One equivalence class per branchin behavior</li> <li>Test inputs computed by Z3, a constraint solver from MSR</li></ul></ul></ul> <p><a href="http://research.microsoft.com/Pex/">Pex</a> and Contracts are the shit.&nbsp; Seriously.&nbsp; After watching this demo I'm all about it.&nbsp; Downloading and installing as soon as I get back home.</p> <p>URL: <a href="http://research.microsoft.com/pex">http://research.microsoft.com/pex</a></p>