<p>(Battery died during Anders' talk.&nbsp; Now I'm sitting all alone in the back of the Dynamic Lanaguages talk by the water cooler stealing some electricity. :))</p> <p>&nbsp;</p> <ul> <li>Dynamic versus Static: WAR! Not really, but people think so. </li> <li>They (They being MS) is working to bring the two together with the DLR.&nbsp; On top of the DLR you have IronPython and IronRuby and now the dynamic features of C# and VB.NET (There is talk of an IronScheme).</li> <li>Things the DLR will give us: Expression Trees, Shared notion of Dynamic Dispatch and Call Site Caching</li> <li>DLR is open source</li> <ul> <li>OSI Approved</li> <li>DLR is on CodePlex </li> <li>DLR will be in .NET 4.0 and VS2010 (AWESOME!)</li> <li>Future stuff will be on CodePlex, maybe making it into product at some time</li></ul> <li>IronPython 1.0 is faster than Python 2.5 (Python 2.5 is written in C)</li> <li>Extending Python is super easy in C#</li> <li>Python to C and C to Python is pain.&nbsp; 2 different object models</li> <li>Python to C# is easy. 1 object model, 1 garbage collector</li> <li>When to use IronPython</li> <ul> <li>Rapid prototyping</li> <li>Python has a lot of libraries</li> <li>Personal tools</li> <li>Test suites</li> <li>build and deployment scripts</li></ul> <li>The meaning of Iron</li> <ul> <li>True Language Implementation</li> <li>True to the community</li> <li>True to the experience</li> <li>Excellent performance</li> <li>Great integration with .NET</li> <li><strong>I</strong>mplemention <strong>R</strong>unning <strong>O</strong>n .<strong>N</strong>ET</li></ul> <li>Things coming up</li> <ul> <li>Script Hosting</li> <li>Compiler as a Service</li></ul> <li>Dynamic Dispatch</li> <ul> <li>Multiple language dynamic dispatch</li> <li>x.Foo turns into GetMember Name = Foo, IgnoreCase = false that the DLR uses in an object binder</li> <li>Easy to write your own binder</li> <li>Common Actions</li> <ul> <li>GetMember</li> <li>SetMember</li> <li>DeleteMember</li> <li>UnaryOperators</li> <li>BinaryOperators</li> <li>Convert</li> <li>InvokeMember</li> <li>Invoke</li> <li>CreateInstance</li> <li>GetIndex</li> <li>SetIndex</li> <li>DeleteIndex</li></ul> <li>Implement System.Dynamic.DynamicObject (I'm totally going to abuse this)</li> <ul> <li>easiest way to play in the dynamic pool</li></ul></ul> <li>Demo of writing a dynamic dispatch object in C# and calling it from IronPython</li> <ul> <li>Now showing how to add a method to a dynamic object (So cool.)</li> <li>Loading the C# assembly into Python and newing up the Bag object and calling methods and setting properties on it.</li></ul> <li>System.Linq.Expressions v2</li> <ul> <li>Start with LINQ Expression Trees</li> <ul> <li>Not really, had their own implementation but almost done getting it converted to LINQ</li></ul> <li>Add assignment</li> <li>Add dynamic nodes</li> <li>All the languages can be mapped to the new and improved LINQ expression trees</li></ul> <li>Different Semantics</li> <ul> <li>x * 2</li> <ul> <li>Assume x = 2 billion</li> <li>In Dynamic Languages that is 4 billion</li> <li>in C# it's -294 million and something</li> <li>We all know why.</li></ul></ul> <li>Trees</li> <ul> <li>Analyzable, transformable and composable</li> <li>Shared tree form with language semantics</li> <li>Optimized machine code</li> <li>Code is collectable</li> <li>Great way to deal with generated code at runtime</li></ul> <li>Callsites</li> <ul> <li>Old Idea: Polymorphic Inline Cache (What?!?!)</li> <ul> <li>Implemented with delegates and generics</li> <li>No changes to CLR</li></ul> <li>Major addition: multiple lanagages on CLR</li> <ul> <li>Interop for sharing objects</li> <li>Customizable</li></ul> <li>CallSite&lt;T&gt;</li> <ul> <li>I'm kinda lost here.&nbsp; Must learn more about CallSites</li></ul> <li>This makes dynamic dispatch fast in .NET</li></ul> <li>Binders work with MetaObjects</li> <ul> <li>Static Objects = fast</li> <li>DynamicObject uses strings. :(</li> <li>So build a MetaObject for your objects/language.</li> <ul> <li>You generate the trees</li> <li>It's hard</li> <li>It's error prone</li></ul> <li>Implement IDynamicObject instead of DynamicObject</li> <li>Must implement a handful of methods on MetaObject</li></ul></ul>