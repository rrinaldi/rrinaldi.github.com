<p>Advances in the .NET type system<br> (Code named: NPIA (No Primary Interop Assemblies))<br>Type embedding and Type equivalence<br>Loose type coupling and extensibility  <p>Challenges:<br>Deployment of PIAs<br>Interop assemblies are large<br> 1.2 Mb for excel  <p>To get the PIAs you need to install the Office 2007 PIA Redistributable: 6.3 Mb  <p>Implementing application extensiblity:<br>COM Interop <br>&nbsp;&nbsp;&nbsp; Complex deployment<br>Managed to Managed<br>&nbsp;&nbsp;&nbsp; Tight type-coupling<br>&nbsp;&nbsp;&nbsp; Versioning is still hard.  <p>Type embedding<br>&nbsp;&nbsp;&nbsp; CLR 4.0 feature<br>&nbsp;&nbsp;&nbsp; Rutime dependency on Interop Assemblies can be eliminated at compile time<br>&nbsp;&nbsp;&nbsp; Information required to call into COM objects is embedded into the assembly  <p>When running no Interop Assembly is ever loaded into memory since it has been completely embedded into your executable<br>Only imports the methods you use in your app.<br>Anything that isnt used is skipped over by the type system (a _VtblGap_ method is inserted instead)  <p>There is a property on PIA references that allows you to tell the compiler to embedde types  <p>Rules:<br>Only metadata is locally embedded<br>&nbsp;&nbsp;&nbsp; Interfaces (must have ComImport and Guid attributes)<br>&nbsp;&nbsp;&nbsp; delegates<br>&nbsp;&nbsp;&nbsp; structs<br>&nbsp;&nbsp;&nbsp; enums<br>&nbsp;&nbsp;&nbsp; no classes or static methods</p> <p>&nbsp;</p> <p>Custom code emitted for new operator:</p> <p>When you new up an object the compiler actually generates a call to Activator.CreateInstance</p> <p>Events are handled through a new ComHelper.Events API</p> <p>Working with Multiple Assembies</p> <blockquote> <p>Helper libraries embed types</p> <p>Now types across multiple assemblies wouldn't be the same</p> <p>Framework handles this and the types will be equivalent.</p></blockquote> <p>Now we are looking into Managed Type Equivalence</p> <p>Type Equivalence allows loose type coupling inside of .NET (which COM allowed)</p> <p>Type Embedding and Type Equivalence are CLR 4.0 features</p> <p>Casts to an equivalent interface</p> <blockquote> <p>CLR Looks for TypeIdentifier attribute to be present on one of the interfaces</p></blockquote> <p>Calls through an equivalent interface</p> <blockquote> <p>COM objects: CLR intercepts the calls and routes them through COM interop (this is the old behavior)</p></blockquote> <p>Extensibility scenario for COM apps:</p> <blockquote> <p>Write add-in code against any verions of host PIA</p> <p>Embed local types using the /link compiler swtich</p> <p>Do not need to deploy the PIAs, just your user code</p> <p>Can compile against Office 2007 PIA and deploy against 2003 and it just works.&nbsp; </p></blockquote> <p>Can be used for managed to managed code</p> <p>Easy way to support interface versioning </p> <p>&nbsp;</p> <p>How is this typesafe?</p> <p>CLR manages it.&nbsp; Casts to interface will succeed. Incompatible calls will fail with System.MethodMissingException</p> <p>Full trust required for embedding structs</p>